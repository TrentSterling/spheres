
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Packed Texture Generator by Trent (Tront) Sterling</title>
    <meta name="description" content="An interactive tool with a live WebGL shader preview for generating procedurally packed textures for game development VFX, created by Trent Sterling.">
    <style>
        :root {
            --bg-color: #0d0f14; --surface-color: #1a1c23; --border-color: #30363d;
            --text-color: #e0e0e0; --text-muted: #8b949e; --accent-color: #2ee6d7;
        }
        body {
            background-color: var(--bg-color);
            background-image: radial-gradient(ellipse at center, rgba(168, 85, 247, 0.15) 0%, rgba(46, 230, 215, 0.1) 30%, transparent 70%);
            color: var(--text-color);
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: clamp(1rem, 5vw, 3rem) 1rem;
            min-height: 100vh;
        }
        main {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }
        h1, h2, h3 { text-align: center; }
        h1 { font-size: clamp(1.8rem, 5vw, 2.8rem); margin-bottom: 2rem; }
        h3 { margin-top: 0; font-size: 1rem; }
        #controls {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: clamp(1rem, 4vw, 1.5rem);
            margin: 2rem auto;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 1rem 1.5rem;
        }
        .control-item { display: flex; flex-direction: column; }
        .control-item label { display: block; margin-bottom: 0.5rem; }
        .control-item span { color: var(--accent-color); font-weight: bold; }
        .control-item input, .control-item select { width: 100%; }
        input[type="number"], select { background: #0d0f14; border: 1px solid var(--border-color); color: var(--text-color); padding: 0.4rem; border-radius: 4px; }
        button {
            background: #5865F2;
            color: white;
            border: 0;
            padding: 0.8rem 2rem;
            border-radius: 8px;
            cursor: pointer;
            margin: 1rem auto;
            display: block;
            font-size: 1.1rem;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        button:hover { background: #4a54b8; }
        #canvas-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }
        .canvas-wrapper {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            padding: 1rem;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas { border: 1px solid #000; max-width: 100%; height: auto; display: block; image-rendering: pixelated; }
        .download-tip { text-align: center; color: var(--text-muted); margin: 1.5rem 0; font-style: italic; }
        footer {
            margin-top: 4rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            color: var(--text-muted);
        }
        footer p { max-width: 70ch; margin: 0 auto 1rem; line-height: 1.7; }
        footer a { color: var(--accent-color); text-decoration: none; font-weight: bold; }
        footer a:hover { text-decoration: underline; }
        video {
            width: 100%;
            max-width: 560px;
            height: auto;
            border-radius: 8px;
            margin: 1.5rem auto 0.5rem;
            display: block;
            border: 1px solid var(--border-color);
        }
        .video-credit {
            font-size: 0.8rem;
            font-style: italic;
            margin-bottom: 1.5rem;
        }
    </style>
</head>
<body>

    <main>
        <h1>Advanced Procedural Tiled Texture Generator</h1>
        
        <div id="controls">
            <div class="control-item" title="Controls the total number of circles to attempt to place in the texture. More circles create a denser pattern.">
                <label for="maxCircles">Total Circles: <span id="maxCirclesValue">450</span></label>
                <input type="range" id="maxCircles" min="10" max="1500" value="450" step="10">
            </div>
            <div class="control-item" title="The smallest possible radius for any circle.">
                <label for="minRadius">Min Radius: <span id="minRadiusValue">3</span></label>
                <input type="range" id="minRadius" min="1" max="50" value="3" step="1">
            </div>
            <div class="control-item" title="The largest possible radius for any circle. A bigger gap between Min and Max radius creates more size variation.">
                <label for="maxRadius">Max Radius: <span id="maxRadiusValue">128</span></label>
                <input type="range" id="maxRadius" min="10" max="256" value="128" step="1">
            </div>
            <div class="control-item" title="How many times the algorithm tries to find a valid spot for each new circle. Higher values result in a more tightly packed layout but can be slower.">
                <label for="placementAttempts">Placement Density: <span id="placementAttemptsValue">100</span></label>
                <input type="range" id="placementAttempts" min="5" max="500" value="100" step="5">
            </div>
            <div class="control-item" title="Influences the size distribution. A value > 0.5 prioritizes placing large circles first, creating a mix of large and small. A value < 0.5 prioritizes small circles.">
                <label for="sizeBias">Size Bias (Big > 0.5 < Small): <span id="sizeBiasValue">0.8</span></label>
                <input type="range" id="sizeBias" min="0" max="1" value="0.8" step="0.01">
            </div>
             <div class="control-item" title="Enter any number for a repeatable layout. Set to 0 or leave empty for a random seed each time.">
                <label for="seed">Seed (0 for random):</label>
                <input type="number" id="seed" value="0">
            </div>
             <div class="control-item" title="The resolution of the output textures. Larger sizes provide more detail but take longer to generate.">
                <label for="textureSize">Texture Size:</label>
                <select id="textureSize">
                    <option value="256">256x256</option>
                    <option value="512">512x512</option>
                    <option value="1024" selected>1024x1024</option>
                    <option value="2048">2048x2048</option>
                </select>
            </div>
        </div>
        
        <button id="randomize-btn">Generate New Layout</button>

        <div id="canvas-container"></div>
        <p class="download-tip">Tip: Click any generated image (except the live preview) to download it as a PNG.</p>
    </main>

    <footer>
        <h2>About This Tool</h2>
        <p>This tool generates a <strong>procedurally packed, seamlessly tileable texture</strong> used for high-performance visual effects (VFX) in game development. Instead of storing color, it "packs" useful data into each of the RGBA color channels. In a game engine's shader, this single texture can be used to efficiently draw and animate thousands of elements like particles, bubbles, or sprites.</p>
        
        <video controls autoplay muted loop playsinline src="twitvid.mp4"></video>
        <p class="video-credit">Video demonstration by <a href="https://x.com/Tuatara_Games/status/1971273501349998621" target="_blank">TUATARA</a></p>

        <p><strong>How it Works:</strong> The Red channel stores each circle's local horizontal (U) coordinate. Green stores the vertical (V) coordinate. Blue stores a unique random grayscale value, allowing a shader to treat each circle individually. The Alpha channel stores a radial gradient, perfect for defining the shape and size. Because the texture is <strong>seamlessly tileable</strong>, it can be repeated infinitely without visible seams, making it ideal for large surfaces.</p>
        <p>This tool was vibecoded by <a href="https://tront.xyz/" target="_blank">Trent 'Tront' Sterling</a> in a single session with Google's Gemini. It's an interactive web implementation inspired by this brilliant <a href="https://x.com/Tuatara_Games/status/1971273501349998621" target="_blank">post from TUATARA</a>.</p>
        <p>
            <a href="https://tront.xyz/" target="_blank">Tront's Hub</a> &nbsp;&bull;&nbsp; 
            <a href="https://github.com/TrentSterling" target="_blank">GitHub</a>
        </p>
    </footer>

    <!-- SHADER CODE -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        attribute vec2 a_tex_coord;
        varying vec2 v_tex_coord;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_tex_coord = a_tex_coord;
        }
    </script>
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        varying vec2 v_tex_coord;
        uniform sampler2D u_packed_texture;
        uniform float u_time;

        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

        void main() {
            vec4 packed_data = texture2D(u_packed_texture, v_tex_coord);
            
            float id = packed_data.b;
            float radial_gradient = packed_data.a;

            float pulse = (sin(u_time * 3.0 + id * 10.0) * 0.5 + 0.5);
            float size_threshold = 1.0 - pulse;
            float circle_mask = smoothstep(size_threshold - 0.02, size_threshold, radial_gradient); // Sharper edge for pixelated look

            if (circle_mask < 0.01) {
                discard;
            }

            vec3 color = hsv2rgb(vec3(id, 0.8, 1.0));
            
            gl_FragColor = vec4(color, 1.0) * circle_mask;
        }
    </script>
    
    <script>
    const controls = { maxCircles: document.getElementById('maxCircles'), minRadius: document.getElementById('minRadius'), maxRadius: document.getElementById('maxRadius'), placementAttempts: document.getElementById('placementAttempts'), sizeBias: document.getElementById('sizeBias'), seed: document.getElementById('seed'), textureSize: document.getElementById('textureSize') };
    const valueSpans = { maxCircles: document.getElementById('maxCirclesValue'), minRadius: document.getElementById('minRadiusValue'), maxRadius: document.getElementById('maxRadiusValue'), placementAttempts: document.getElementById('placementAttemptsValue'), sizeBias: document.getElementById('sizeBiasValue'), };
    const randomizeBtn = document.getElementById('randomize-btn');
    
    let rng; function mulberry32(a) { return function() { a |= 0; a = a + 0x6D2B79F5 | 0; let t = Math.imul(a ^ a >>> 15, 1 | a); t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t; return ((t ^ t >>> 14) >>> 0) / 4294967296; } }
    
    let webGLCanvas;

    function runGeneration() {
        const currentConfig = { canvasSize: parseInt(controls.textureSize.value, 10), maxCircles: parseInt(controls.maxCircles.value, 10), minRadius: parseInt(controls.minRadius.value, 10), maxRadius: parseInt(controls.maxRadius.value, 10), placementAttempts: parseInt(controls.placementAttempts.value, 10), sizeBias: parseFloat(controls.sizeBias.value), seed: parseInt(controls.seed.value, 10) || Math.floor(Math.random() * 1000000) };
        if (parseInt(controls.seed.value, 10) === 0) { controls.seed.value = currentConfig.seed; }
        rng = mulberry32(currentConfig.seed);
        
        webGLCanvas.width = currentConfig.canvasSize;
        webGLCanvas.height = currentConfig.canvasSize;

        const circlesLayout = generateHierarchicalPackedCircles(currentConfig);
        const allPixelData = generateAllPixelData(circlesLayout, currentConfig.canvasSize);

        const uCanvas = getOrCreateCanvas('uCanvas', currentConfig.canvasSize), vCanvas = getOrCreateCanvas('vCanvas', currentConfig.canvasSize), idCanvas = getOrCreateCanvas('idCanvas', currentConfig.canvasSize), gradientCanvas = getOrCreateCanvas('gradientCanvas', currentConfig.canvasSize), packedCanvas = getOrCreateCanvas('packedCanvas', currentConfig.canvasSize);
        
        uCanvas.getContext('2d').putImageData(allPixelData.u, 0, 0);
        vCanvas.getContext('2d').putImageData(allPixelData.v, 0, 0);
        idCanvas.getContext('2d').putImageData(allPixelData.id, 0, 0);
        gradientCanvas.getContext('2d').putImageData(allPixelData.gradient, 0, 0);

        packTextures(packedCanvas, allPixelData);
        displayCanvases({ "U Coordinate (R Channel)": uCanvas, "V Coordinate (G Channel)": vCanvas, "Unique ID / Random Value (B Channel)": idCanvas, "Normalized Radial Gradient (A Channel)": gradientCanvas, "Packed Texture (RGBA)": packedCanvas, "Live Shader Preview": webGLCanvas });
        updateWebGLPackedTexture(packedCanvas);
    }

    for (const key in valueSpans) { controls[key].addEventListener('input', () => { valueSpans[key].textContent = controls[key].value; runGeneration(); }); }
    controls.seed.addEventListener('input', runGeneration);
    controls.textureSize.addEventListener('input', runGeneration);
    randomizeBtn.addEventListener('click', () => { controls.seed.value = 0; runGeneration(); });
    window.addEventListener('load', () => { webGLCanvas = initWebGLPreview(); runGeneration(); });

    function generateHierarchicalPackedCircles(config) { const { canvasSize, maxCircles, minRadius, maxRadius, placementAttempts, sizeBias } = config; let circles = []; for (let i = 0; i < maxCircles; i++) { let newCircle = null; for (let attempt = 0; attempt < placementAttempts; attempt++) { const biasedMaxRadius = minRadius + (Math.pow(rng(), 1 / (sizeBias || 0.5)) * (maxRadius - minRadius)); const potentialCircle = { x: rng() * canvasSize, y: rng() * canvasSize, r: minRadius, id: rng(), maxR: biasedMaxRadius }; let hasOverlap = circles.some(existing => { for (let dx = -1; dx <= 1; dx++) for (let dy = -1; dy <= 1; dy++) { if (Math.hypot(potentialCircle.x - (existing.x + dx * canvasSize), potentialCircle.y - (existing.y + dy * canvasSize)) < potentialCircle.r + existing.r) return true; } return false; }); if (!hasOverlap) { newCircle = potentialCircle; break; } } if (!newCircle) continue; while (newCircle.r < newCircle.maxR) { newCircle.r += 1; let hasCollision = circles.some(existing => { for (let dx = -1; dx <= 1; dx++) for (let dy = -1; dy <= 1; dy++) { if (Math.hypot(newCircle.x - (existing.x + dx * canvasSize), newCircle.y - (existing.y + dy * canvasSize)) < newCircle.r + existing.r + 1) return true; } return false; }); if (hasCollision) { newCircle.r -= 1; break; } } circles.push(newCircle); } return circles; }
    
    // --- INTEGRATING THE PER-PIXEL RENDERER ---
    function generateAllPixelData(circles, size) {
        const uCtx = document.createElement('canvas').getContext('2d');
        const uImageData = uCtx.createImageData(size, size);
        const vImageData = uCtx.createImageData(size, size);
        const idImageData = uCtx.createImageData(size, size);
        const gradientImageData = uCtx.createImageData(size, size);

        const cellSize = (circles.reduce((max, c) => Math.max(max, c.r), 0) * 2) || 64;
        const grid = new Map();
        for (const circle of circles) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const circleInstance = { ...circle, x: circle.x + dx * size, y: circle.y + dy * size };
                    const minX = Math.floor((circleInstance.x - circleInstance.r) / cellSize);
                    const maxX = Math.floor((circleInstance.x + circleInstance.r) / cellSize);
                    const minY = Math.floor((circleInstance.y - circleInstance.r) / cellSize);
                    const maxY = Math.floor((circleInstance.y + circleInstance.r) / cellSize);
                    for(let gy = minY; gy <= maxY; gy++) {
                        for(let gx = minX; gx <= maxX; gx++) {
                            const key = `${gx},${gy}`;
                            if(!grid.has(key)) grid.set(key, []);
                            grid.get(key).push(circleInstance);
                        }
                    }
                }
            }
        }

        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                let insideCircle = null;
                const gridX = Math.floor(x / cellSize);
                const gridY = Math.floor(y / cellSize);
                const key = `${gridX},${gridY}`;
                const circlesToCheck = grid.get(key) || [];

                for (const circle of circlesToCheck) {
                    const dist_sq = (x - circle.x) * (x - circle.x) + (y - circle.y) * (y - circle.y);
                    if (dist_sq <= circle.r * circle.r) {
                        insideCircle = circle;
                        break;
                    }
                }

                const index = (y * size + x) * 4;
                if (insideCircle) {
                    const dist = Math.hypot(x-insideCircle.x, y-insideCircle.y);
                    const radius = insideCircle.r;

                    const u = ((x - (insideCircle.x - radius)) / (2 * radius));
                    const v = ((y - (insideCircle.y - radius)) / (2 * radius));
                    const id = insideCircle.id;
                    const grad = 1.0 - (dist / radius);

                    const uVal = Math.floor(u * 255), vVal = Math.floor(v * 255), idVal = Math.floor(id * 255), gradVal = Math.floor(grad * 255);
                    uImageData.data.set([uVal, uVal, uVal, 255], index);
                    vImageData.data.set([vVal, vVal, vVal, 255], index);
                    idImageData.data.set([idVal, idVal, idVal, 255], index);
                    gradientImageData.data.set([gradVal, gradVal, gradVal, 255], index);
                } else {
                     for(let i=0; i<4; ++i) { uImageData.data[index+i] = vImageData.data[index+i] = idImageData.data[index+i] = gradientImageData.data[index+i] = (i==3 ? 255 : 0); }
                }
            }
        }
        return { u: uImageData, v: vImageData, id: idImageData, gradient: gradientImageData };
    }

    function packTextures(packedCanvas, allPixelData) { 
        const ctx = packedCanvas.getContext('2d');
        const size = packedCanvas.width;
        const packedImageData = ctx.createImageData(size, size); 
        for (let i = 0; i < packedImageData.data.length; i += 4) {
            packedImageData.data[i + 0] = allPixelData.u.data[i];
            packedImageData.data[i + 1] = allPixelData.v.data[i];
            packedImageData.data[i + 2] = allPixelData.id.data[i];
            packedImageData.data[i + 3] = allPixelData.gradient.data[i];
        }
        ctx.putImageData(packedImageData, 0, 0); 
    }
    
    // --- THIS SECTION IS FROM YOUR STABLE CODE ---
    function getOrCreateCanvas(id, size) { let canvas = document.getElementById(id); if (!canvas) { canvas = document.createElement('canvas'); canvas.id = id; } canvas.width = size; canvas.height = size; return canvas; }
    function displayCanvases(canvases) { const container = document.getElementById('canvas-container'); container.innerHTML = ''; for (const title in canvases) { const canvas = canvases[title]; if (!canvas) continue; const wrapper = document.createElement('div'); wrapper.className = 'canvas-wrapper'; const h3 = document.createElement('h3'); h3.textContent = title; let elementToAppend = canvas; if (!title.includes('Preview')) { const link = document.createElement('a'); link.href = canvas.toDataURL('image/png'); link.download = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.png`; link.appendChild(canvas); elementToAppend = link; } wrapper.appendChild(h3); wrapper.appendChild(elementToAppend); container.appendChild(wrapper); }}
    
    let gl, shaderProgram, packedTextureObject, timeUniform;
    function initWebGLPreview() {
        const canvas = document.createElement('canvas'); canvas.id = 'webgl-preview'; canvas.width = 1024; canvas.height = 1024;
        gl = canvas.getContext('webgl', { antialias: true, premultipliedAlpha: false }); if (!gl) { console.error("WebGL not supported!"); return null; }
        const vertShader = createShader(gl, gl.VERTEX_SHADER, document.getElementById('vertex-shader').text);
        const fragShader = createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fragment-shader').text);
        shaderProgram = createProgram(gl, vertShader, fragShader); gl.useProgram(shaderProgram);
        const positionAttribLocation = gl.getAttribLocation(shaderProgram, 'a_position');
        const texCoordAttribLocation = gl.getAttribLocation(shaderProgram, 'a_tex_coord');
        timeUniform = gl.getUniformLocation(shaderProgram, 'u_time');
        const packedTexUniform = gl.getUniformLocation(shaderProgram, 'u_packed_texture');
        const positions = [-1, 1, -1, -1, 1, 1, 1, -1]; const texCoords = [0, 1, 0, 0, 1, 1, 1, 0];
        setupBuffer(gl, positions, positionAttribLocation, 2); setupBuffer(gl, texCoords, texCoordAttribLocation, 2);
        
        packedTextureObject = createWebGLTexture(gl);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, packedTextureObject);
        gl.uniform1i(packedTexUniform, 0);
        
        requestAnimationFrame(renderWebGL);
        return canvas;
    }
    
    function createShader(gl, type, source) { const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader); if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader; console.error("Shader compile error:", gl.getShaderInfoLog(shader)); gl.deleteShader(shader); }
    function createProgram(gl, vert, frag) { const program = gl.createProgram(); gl.attachShader(program, vert); gl.attachShader(program, frag); gl.linkProgram(program); if (gl.getProgramParameter(program, gl.LINK_STATUS)) return program; console.error("Program link error:", gl.getProgramInfoLog(program)); gl.deleteProgram(program); }
    function setupBuffer(gl, data, attribLocation, size) { const buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW); gl.enableVertexAttribArray(attribLocation); gl.vertexAttribPointer(attribLocation, size, gl.FLOAT, false, 0, 0); }
    function createWebGLTexture(gl) { const tex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, tex); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); return tex; } // Use NEAREST for sharp pixels
    
    function updateWebGLPackedTexture(sourceCanvas) {
        if (!gl || !packedTextureObject) return;
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, packedTextureObject);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, sourceCanvas);
    }

    function renderWebGL(time) {
        if (!gl) return;
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clearColor(0.09, 0.10, 0.14, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.uniform1f(timeUniform, time * 0.001);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(renderWebGL);
    }
    </script>
</body>
</html>
