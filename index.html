
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Packed Texture Generator by Trent (Tront) Sterling</title>
    <meta name="description" content="An interactive tool for generating procedurally packed and tiled textures for game development VFX, inspired by TUATARA and created by Trent Sterling with Gemini.">
    <style>
        :root {
            --bg-color: #0d0f14; --surface-color: #1a1c23; --border-color: #30363d;
            --text-color: #e0e0e0; --text-muted: #8b949e; --accent-color: #2ee6d7;
        }
        body {
            background-color: var(--bg-color);
            background-image: radial-gradient(ellipse at center, rgba(168, 85, 247, 0.15) 0%, rgba(46, 230, 215, 0.1) 30%, transparent 70%);
            color: var(--text-color);
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: clamp(1rem, 5vw, 3rem) 1rem;
            min-height: 100vh;
        }
        main {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }
        h1, h2, h3 { text-align: center; }
        h1 { font-size: clamp(1.8rem, 5vw, 2.8rem); margin-bottom: 2rem; }
        h3 { margin-top: 0; font-size: 1rem; }
        #controls {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: clamp(1rem, 4vw, 1.5rem);
            margin: 2rem auto;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 1rem 1.5rem;
        }
        .control-item { display: flex; flex-direction: column; }
        .control-item label { display: block; margin-bottom: 0.5rem; }
        .control-item span { color: var(--accent-color); font-weight: bold; }
        .control-item input { width: 100%; }
        input[type="number"] { background: #0d0f14; border: 1px solid var(--border-color); color: var(--text-color); padding: 0.4rem; border-radius: 4px; }
        button {
            background: #5865F2;
            color: white;
            border: 0;
            padding: 0.8rem 2rem;
            border-radius: 8px;
            cursor: pointer;
            margin: 1rem auto;
            display: block;
            font-size: 1.1rem;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        button:hover { background: #4a54b8; }
        #canvas-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }
        .canvas-wrapper {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            padding: 1rem;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas { border: 1px solid #000; max-width: 100%; height: auto; display: block; }
        .download-tip { text-align: center; color: var(--text-muted); margin: 1.5rem 0; font-style: italic; }
        footer {
            margin-top: 4rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            color: var(--text-muted);
        }
        footer p { max-width: 70ch; margin: 0 auto 1rem; line-height: 1.7; }
        footer a { color: var(--accent-color); text-decoration: none; font-weight: bold; }
        footer a:hover { text-decoration: underline; }
    </style>
</head>
<body>

    <main>
        <h1>Advanced Procedural Tiled Texture Generator</h1>
        
        <div id="controls">
            <div class="control-item" title="Controls the total number of circles to attempt to place in the texture. More circles create a denser pattern.">
                <label for="maxCircles">Total Circles: <span id="maxCirclesValue">450</span></label>
                <input type="range" id="maxCircles" min="10" max="1500" value="450" step="10">
            </div>
            <div class="control-item" title="The smallest possible radius for any circle.">
                <label for="minRadius">Min Radius: <span id="minRadiusValue">3</span></label>
                <input type="range" id="minRadius" min="1" max="50" value="3" step="1">
            </div>
            <div class="control-item" title="The largest possible radius for any circle. A bigger gap between Min and Max radius creates more size variation.">
                <label for="maxRadius">Max Radius: <span id="maxRadiusValue">128</span></label>
                <input type="range" id="maxRadius" min="10" max="256" value="128" step="1">
            </div>
            <div class="control-item" title="How many times the algorithm tries to find a valid spot for each new circle. Higher values result in a more tightly packed layout but can be slower.">
                <label for="placementAttempts">Placement Density: <span id="placementAttemptsValue">100</span></label>
                <input type="range" id="placementAttempts" min="5" max="500" value="100" step="5">
            </div>
            <div class="control-item" title="Influences the size distribution. A value > 0.5 prioritizes placing large circles first, creating a mix of large and small. A value < 0.5 prioritizes small circles.">
                <label for="sizeBias">Size Bias (Big > 0.5 < Small): <span id="sizeBiasValue">0.8</span></label>
                <input type="range" id="sizeBias" min="0" max="1" value="0.8" step="0.01">
            </div>
             <div class="control-item" title="Enter any number for a repeatable layout. Set to 0 or leave empty for a random seed each time.">
                <label for="seed">Seed (0 for random):</label>
                <input type="number" id="seed" value="0">
            </div>
        </div>
        
        <button id="randomize-btn">Generate New Layout</button>

        <div id="canvas-container"></div>
        <p class="download-tip">Tip: Click any generated image to download it as a PNG.</p>
    </main>

    <footer>
        <h2>About This Tool</h2>
        <p>This tool generates a <strong>procedurally packed, seamlessly tileable texture</strong> used for high-performance visual effects (VFX) in game development. Instead of storing color, it "packs" useful data into each of the RGBA color channels. In a game engine's shader, this single texture can be used to efficiently draw and animate thousands of elements like particles, bubbles, or sprites.</p>
        <p><strong>How it Works:</strong> The Red channel stores each circle's local horizontal (U) coordinate. Green stores the vertical (V) coordinate. Blue stores a unique random grayscale value, allowing a shader to treat each circle individually. The Alpha channel stores a radial gradient, perfect for defining the shape and size. Because the texture is <strong>seamlessly tileable</strong>, it can be repeated infinitely without visible seams, making it ideal for large surfaces.</p>
        <p>This tool was vibecoded by <a href="https://tront.xyz/" target="_blank">Trent 'Tront' Sterling</a> in a single session with Google's Gemini. It's an interactive web implementation inspired by this brilliant <a href="https://x.com/Tuatara_Games/status/1971273501349998621" target="_blank">post from TUATARA</a>.</p>
        <p>
            <a href="https://tront.xyz/" target="_blank">Tront's Hub</a> &nbsp;&bull;&nbsp; 
            <a href="https://github.com/TrentSterling" target="_blank">GitHub</a>
        </p>
    </footer>

    <script>
    // --- DOM ELEMENT REFERENCES ---
    const controls = {
        maxCircles: document.getElementById('maxCircles'),
        minRadius: document.getElementById('minRadius'),
        maxRadius: document.getElementById('maxRadius'),
        placementAttempts: document.getElementById('placementAttempts'),
        sizeBias: document.getElementById('sizeBias'),
        seed: document.getElementById('seed'),
    };
    const valueSpans = {
        maxCircles: document.getElementById('maxCirclesValue'),
        minRadius: document.getElementById('minRadiusValue'),
        maxRadius: document.getElementById('maxRadiusValue'),
        placementAttempts: document.getElementById('placementAttemptsValue'),
        sizeBias: document.getElementById('sizeBiasValue'),
    };
    const randomizeBtn = document.getElementById('randomize-btn');
    
    // --- SEEDABLE PRNG ---
    let rng;
    function mulberry32(a) {
        return function() {
            a |= 0; a = a + 0x6D2B79F5 | 0;
            let t = Math.imul(a ^ a >>> 15, 1 | a);
            t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
    }
    
    // --- MAIN EXECUTION ---
    function runGeneration() {
        const currentConfig = {
            canvasSize: 512,
            maxCircles: parseInt(controls.maxCircles.value, 10),
            minRadius: parseInt(controls.minRadius.value, 10),
            maxRadius: parseInt(controls.maxRadius.value, 10),
            placementAttempts: parseInt(controls.placementAttempts.value, 10),
            sizeBias: parseFloat(controls.sizeBias.value),
            seed: parseInt(controls.seed.value, 10) || Math.floor(Math.random() * 1000000)
        };
        
        // Update the seed input if it was random
        if (parseInt(controls.seed.value, 10) === 0) {
            controls.seed.value = currentConfig.seed;
        }
        
        // Initialize the seeded random number generator
        rng = mulberry32(currentConfig.seed);

        const circlesLayout = generateHierarchicalPackedCircles(currentConfig);

        const uCanvas = getOrCreateCanvas('uCanvas', currentConfig.canvasSize);
        const vCanvas = getOrCreateCanvas('vCanvas', currentConfig.canvasSize);
        const idCanvas = getOrCreateCanvas('idCanvas', currentConfig.canvasSize);
        const gradientCanvas = getOrCreateCanvas('gradientCanvas', currentConfig.canvasSize);
        const packedCanvas = getOrCreateCanvas('packedCanvas', currentConfig.canvasSize);

        renderUCoordinateTexture(uCanvas.getContext('2d'), circlesLayout, currentConfig.canvasSize);
        renderVCoordinateTexture(vCanvas.getContext('2d'), circlesLayout, currentConfig.canvasSize);
        renderIdTexture(idCanvas.getContext('2d'), circlesLayout, currentConfig.canvasSize);
        renderRadialGradientTexture(gradientCanvas.getContext('2d'), circlesLayout, currentConfig.canvasSize);
        packTextures(packedCanvas.getContext('2d'), uCanvas, vCanvas, idCanvas, gradientCanvas, currentConfig.canvasSize);
        
        displayCanvases({
            "U Coordinate (R Channel)": uCanvas,
            "V Coordinate (G Channel)": vCanvas,
            "Unique ID / Random Value (B Channel)": idCanvas,
            "Normalized Radial Gradient (A Channel)": gradientCanvas,
            "Packed Texture (RGBA)": packedCanvas
        });
    }

    // Set up listeners for all sliders to update values and re-render
    for (const key in valueSpans) {
        controls[key].addEventListener('input', () => {
            valueSpans[key].textContent = controls[key].value;
            runGeneration();
        });
    }
    // Listeners for inputs that don't have a value span
    controls.seed.addEventListener('input', runGeneration);
    randomizeBtn.addEventListener('click', () => {
        // Force a random seed when the button is clicked
        controls.seed.value = 0;
        runGeneration();
    });
    
    // Initial generation on page load
    window.addEventListener('load', runGeneration);

    /**
     * Generates circles one-by-one, using the seeded RNG.
     */
    function generateHierarchicalPackedCircles(config) {
        const { canvasSize, maxCircles, minRadius, maxRadius, placementAttempts, sizeBias } = config;
        let circles = [];

        for (let i = 0; i < maxCircles; i++) {
            let newCircle = null;
            for (let attempt = 0; attempt < placementAttempts; attempt++) {
                const biasedMaxRadius = minRadius + (Math.pow(rng(), 1 / (sizeBias || 0.5)) * (maxRadius - minRadius));
                const potentialCircle = {
                    x: rng() * canvasSize, y: rng() * canvasSize,
                    r: minRadius, id: rng(), maxR: biasedMaxRadius
                };

                let hasOverlap = circles.some(existing => {
                    for (let dx = -1; dx <= 1; dx++) for (let dy = -1; dy <= 1; dy++) {
                        const x2 = existing.x + dx * canvasSize, y2 = existing.y + dy * canvasSize;
                        if (Math.hypot(potentialCircle.x - x2, potentialCircle.y - y2) < potentialCircle.r + existing.r) return true;
                    }
                    return false;
                });
                if (!hasOverlap) { newCircle = potentialCircle; break; }
            }
            if (!newCircle) continue;

            while (newCircle.r < newCircle.maxR) {
                newCircle.r += 1;
                let hasCollision = circles.some(existing => {
                    for (let dx = -1; dx <= 1; dx++) for (let dy = -1; dy <= 1; dy++) {
                        const x2 = existing.x + dx * canvasSize, y2 = existing.y + dy * canvasSize;
                        if (Math.hypot(newCircle.x - x2, newCircle.y - y2) < newCircle.r + existing.r + 1) return true;
                    }
                    return false;
                });
                if (hasCollision) { newCircle.r -= 1; break; }
            }
            circles.push(newCircle);
        }
        return circles;
    }

    // --- HELPER, RENDERING, and PACKING FUNCTIONS (Unchanged from previous version) ---
    function getOrCreateCanvas(id, size) {
        let canvas = document.getElementById(id);
        if (!canvas) {
            canvas = document.createElement('canvas');
            canvas.id = id;
            canvas.width = size;
            canvas.height = size;
        }
        return canvas;
    }

    function drawTiled(ctx, size, drawCallback) {
        for (let dx = -1; dx <= 1; dx++) for (let dy = -1; dy <= 1; dy++) {
            ctx.save();
            ctx.translate(dx * size, dy * size);
            drawCallback(ctx);
            ctx.restore();
        }
    }

    function renderUCoordinateTexture(ctx, circles, size) {
        ctx.fillStyle = 'black'; ctx.fillRect(0, 0, size, size);
        circles.forEach(circle => drawTiled(ctx, size, (tiledCtx) => {
            const gradient = tiledCtx.createLinearGradient(circle.x - circle.r, 0, circle.x + circle.r, 0);
            gradient.addColorStop(0, 'black'); gradient.addColorStop(1, 'white');
            tiledCtx.beginPath(); tiledCtx.arc(circle.x, circle.y, circle.r, 0, 2 * Math.PI);
            tiledCtx.fillStyle = gradient; tiledCtx.fill();
        }));
    }

    function renderVCoordinateTexture(ctx, circles, size) {
        ctx.fillStyle = 'black'; ctx.fillRect(0, 0, size, size);
        circles.forEach(circle => drawTiled(ctx, size, (tiledCtx) => {
            const gradient = tiledCtx.createLinearGradient(0, circle.y - circle.r, 0, circle.y + circle.r);
            gradient.addColorStop(0, 'black'); gradient.addColorStop(1, 'white');
            tiledCtx.beginPath(); tiledCtx.arc(circle.x, circle.y, circle.r, 0, 2 * Math.PI);
            tiledCtx.fillStyle = gradient; tiledCtx.fill();
        }));
    }

    function renderIdTexture(ctx, circles, size) {
        ctx.fillStyle = 'black'; ctx.fillRect(0, 0, size, size);
        circles.forEach(circle => {
            const intensity = Math.floor(circle.id * 255);
            const color = `rgb(${intensity}, ${intensity}, ${intensity})`;
            drawTiled(ctx, size, (tiledCtx) => {
                tiledCtx.beginPath(); tiledCtx.arc(circle.x, circle.y, circle.r, 0, 2 * Math.PI);
                tiledCtx.fillStyle = color; tiledCtx.fill();
            });
        });
    }

    function renderRadialGradientTexture(ctx, circles, size) {
        ctx.fillStyle = 'black'; ctx.fillRect(0, 0, size, size);
        circles.forEach(circle => drawTiled(ctx, size, (tiledCtx) => {
            const gradient = tiledCtx.createRadialGradient(circle.x, circle.y, 0, circle.x, circle.y, circle.r);
            gradient.addColorStop(0, 'white'); gradient.addColorStop(1, 'black');
            tiledCtx.beginPath(); tiledCtx.arc(circle.x, circle.y, circle.r, 0, 2 * Math.PI);
            tiledCtx.fillStyle = gradient; tiledCtx.fill();
        }));
    }
    
    function packTextures(ctx, uCanvas, vCanvas, idCanvas, gradientCanvas, size) {
        const uData = uCanvas.getContext('2d').getImageData(0, 0, size, size).data;
        const vData = vCanvas.getContext('2d').getImageData(0, 0, size, size).data;
        const idData = idCanvas.getContext('2d').getImageData(0, 0, size, size).data;
        const gradientData = gradientCanvas.getContext('2d').getImageData(0, 0, size, size).data;
        const packedImageData = ctx.createImageData(size, size);
        for (let i = 0; i < packedImageData.data.length; i += 4) {
            packedImageData.data[i + 0] = uData[i];
            packedImageData.data[i + 1] = vData[i];
            packedImageData.data[i + 2] = idData[i];
            packedImageData.data[i + 3] = gradientData[i];
        }
        ctx.putImageData(packedImageData, 0, 0);
    }
    
    function displayCanvases(canvases) {
        const container = document.getElementById('canvas-container');
        if (container.children.length === 0) {
            for (const title in canvases) {
                const canvas = canvases[title];
                const wrapper = document.createElement('div');
                wrapper.className = 'canvas-wrapper';
                const h3 = document.createElement('h3');
                h3.textContent = title;
                const link = document.createElement('a');
                link.href = canvas.toDataURL('image/png');
                link.download = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.png`;
                link.appendChild(canvas);
                wrapper.appendChild(h3);
                wrapper.appendChild(link);
                container.appendChild(wrapper);
            }
        }
    }
    </script>
</body>
</html>
